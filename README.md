# Java BIO NIO AIO

## 同步、异步、阻塞、非阻塞

[简述linux同步与异步、阻塞与非阻塞概念以及五种IO模型](http://www.cnblogs.com/chaser24/p/6112071.html)

上面的文章中介绍了什么是同步异步阻塞和非阻塞。

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。


2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）


3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。


4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞。

阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回。

同步和阻塞的区别是：对于同步来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。而对阻塞来说，当前线程是被挂起的。

五种IO模型：

1)阻塞I/O（blocking I/O）
2)非阻塞I/O （nonblocking I/O）
3) I/O复用(select 和poll) （I/O multiplexing）
4)信号驱动I/O （signal driven I/O (SIGIO)）
5)异步I/O （asynchronous I/O (the POSIX aio_functions)）

其中前4种都是同步，最后一种才是异步。

![img](http://images2015.cnblogs.com/blog/1066890/201611/1066890-20161129014959615-1351089676.png)

## Java IO的演化

JAVA IO也经历来上面几次演化，**从最早的BIO（阻塞式/非阻塞IO），到1.4版本的NIO（IO复用），到1.7版本的NIO2.0/AIO（异步IO）**；基于早期BIO来实现高并发网络服务器都是依赖多线程来实现，但是线程开销较大，BIO的瓶颈明显，NIO的出现解决了这一大难题，基于IO复用解决了IO高并发。

## Java NIO的特点

1.面向缓冲区而不是面向流

IO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区（buffer有多个状态位）。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

2.可以是非阻塞的

IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

3.在网络操作方面的IO复用

什么是IO复用？

技术上的问题，是将IO操作中等待和非等待的部分分开处理。我们都知道IO操作分为两个部分：
1、等待数据就绪
2、处理数据

众所周知的几种IO模型（阻塞、非阻塞、多路复用、信号驱动、异步）就是区别于这两个阶段，当需要处理很多连接的时候（高并发的情况），容易想到的是使用多线程技术，比如最简单的One-connection-Per-thread模式，但是因为等待数据不可避免，造成的结果是线程不停的休眠-唤醒的切换，导致CPU不堪重负。

IO复用的目的：将这两个阶段分开处理，让一个线程（而且是内核级别的线程）来处理所有的等待，一旦有相应的IO事件发生就通知继续完成IO操作，虽然仍然有阻塞和等待，但是等待总是发生在一个线程，这时使用多线程可以保证其他线程一旦唤醒就是处理数据，当然这需要非阻塞IO API的支持（比如非阻塞套接字）。Linux2.6之前的select,poll以及之后的epoll都是IO复用技术的实现。**select**和**poll**基本一致，**epoll**是对它们的改进版本。但总的来说它们都还不是真正的异步IO，因为它们在IO读写的时候仍然是阻塞的、同步的（完成一件事后才能做另外一件事）。异步IO是指“处理数据”这一阶段也是非阻塞的。Windows上的IOCP（完成端口）才是真正的AIO，理论上它比Linux的epoll更先进。

[攻破Java NIO技术壁垒](http://www.importnew.com/19816.html)

## Java AIO的特点

AIO是异步IO的缩写，即Asynchronized。虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程实在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身还是同步的。

但是对于AIO来说，则更加进了异步，它不是在IO准备好时再通知线程，而是再IO操作已经完成后，再给线程发出通知。因此，AIO时完全不会阻塞的，此时，我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。

**此外在回调函数中读写通道也用异步的Future来完成。**

NIO和AIO的示例代码在https://github.com/RongtongJin/NIOAndAIODemo

